1)
a_ Proceso:
• Programa en ejecucion
• Los conceptos de tarea, job y proceso hacen referencia a lo
mismo
• Segun su historial de ejecucion, los podemos clasificar en:
• CPU Bound (ligados a la CPU)
• I/O Bound (ligados a entrada/salida)
• Es dinamico
• Tiene program counter
• Su ciclo de vida comprende desde que se lo ejecuta hasta que
termina

Programa:
• Es estatico
• No tiene program counter
• Existe desde que se edita hasta que se borra

b_ Tiempos de los procesos
• Retorno: tiempo que transcurre entre que el proceso llega al
sistema hasta que completa su ejecucion.
• Espera: tiempo que el proceso se encuentra en el sistema
esperando.

c_ Promedios: tiempos promedio de los anteriores.

d_ Quantum (Q): medida que determina cuanto tiempo
podra usar el procesador cada proceso.

e_ Nonpreemptive: una vez que un proceso esta en estado de
ejecucion, continua hasta que termina o se bloquea por algun
evento (e.j. I/O)

Preemptive: el proceso en ejecucion puede ser interrumpido y
llevado a la cola de listos:
    • Mayor overhead pero mejor servicio
    • Un proceso no monopoliza el procesador

f_ Short term scheduler: determina que proceso pasara a
ejecutarse.
Medium term scheduler: realiza el swapping (intercambio)
entre el disco y la memoria cuando el SO lo determina (puede
disminuir el grado de multiprogramacion).
Long term scheduler: admite nuevos procesos a memoria
(controla el grado de multirpogramacion).

g_ El dispatcher se encarga de asignar el tiempo de CPU a los procesos y de cambiar
entre procesos (lo que llamamos context switching). En otras palabras, decide qué 
proceso debe ejecutarse en cada momento para asegurar un uso eficiente del procesador.

2)
i. top
Descripción: Muestra en tiempo real una lista de los procesos que se están ejecutando en el sistema, 
ordenados por el uso de CPU.
Comando:
top

ii. htop
Descripción: Una versión mejorada de top con una interfaz más amigable y funcionalidad ampliada.
Comando:
htop

iii. ps
Descripción: Muestra una instantánea de los procesos en ejecución en el sistema.
Comando:
ps aux     # Lista todos los procesos en detalle
ps -ef     # Otra opción para mostrar todos los procesos

iv. pstree
Descripción: Muestra los procesos en ejecución en una estructura jerárquica o de árbol.
Comando:
pstree

v. kill
Descripción: Envía una señal a un proceso específico, generalmente para terminarlo.
Comando:
kill 1234        # Envía la señal de terminación al proceso con PID 1234
kill -9 1234     # Envía la señal forzada (KILL) al proceso con PID 1234

vi. pgrep
Descripción: Busca procesos en ejecución por nombre y devuelve sus PIDs.
Comando:
pgrep nombre_proceso

vii. killall
Descripción: Termina todos los procesos que coincidan con un nombre específico.
Comando:
killall nombre_proceso

viii. renice
Descripción: Cambia la prioridad de ejecución de un proceso en ejecución.
Comando:
renice -n 10 -p 1234   # Cambia la prioridad del proceso con PID 1234 a 10

ix. xkill
Descripción: Permite seleccionar una ventana gráfica para matar el proceso que la controla.
Comando:
xkill

x. atop
Descripción: Una herramienta avanzada de monitoreo que muestra información detallada de procesos 
y de los recursos de hardware (CPU, memoria, disco, red).
Comando:
atop

b_ 
i. Al final de la ejecucion del programa habran 8 lineas con la palabra Proceso.
ii. El número de líneas es el número de procesos que han estado en ejecución

c_
proceso 7
proceso 6
proceso 5
proceso 4 
proceso 3
proceso 2   
proceso 1
proceso 0
ii. Tendran valores distintos. Cambia el numero.

Se ejecuta proceso N 2 elevado a la c veces.

d_ i. 
Comunicación entre procesos a través de pipes
Los pipes permiten la comunicación entre procesos en sistemas operativos como Unix/Linux, 
funcionando como un canal unidireccional por el cual un proceso puede enviar datos a otro. 
Existen dos tipos de pipes:

Pipes anónimos: Son temporales y sirven para la comunicación entre procesos relacionados (por ejemplo, procesos padre-hijo).
Named pipes o FIFOs: Persisten en el sistema de archivos y permiten la comunicación entre procesos no relacionados.
Los pipes permiten que un proceso escriba datos en un extremo y otro proceso los lea desde el otro extremo, 
actuando como un archivo temporal de lectura/escritura.

ii. ¿Cómo se crea un pipe en C?
Para crear un pipe en C se utiliza la función pipe(), que pertenece a la biblioteca estándar <unistd.h>. 
Esta función crea un pipe anónimo y devuelve dos descriptores de archivo (file descriptors): uno para lectura y 
otro para escritura.

#include <stdio.h>
#include <unistd.h>

int main() {
    int fd[2];  // Array para almacenar los descriptores de archivo

    // Crea el pipe
    if (pipe(fd) == -1) {
        perror("Error al crear el pipe");
        return 1;
    }

    // Ahora `fd[0]` es el extremo de lectura y `fd[1]` es el extremo de escritura.
    // Para usarlo, un proceso puede escribir en `fd[1]` y otro puede leer de `fd[0]`.

    return 0;
}
iii. ¿Qué parámetro es necesario para la creación de un pipe?
La función pipe() recibe un solo parámetro:

int pipe(int pipefd[2]);
Parámetro pipefd[2]
pipefd es un array de dos enteros que se utilizará para almacenar los descriptores de archivo:
pipefd[0] es el descriptor de lectura del pipe.
pipefd[1] es el descriptor de escritura del pipe.
Al crear el pipe, se establece esta pareja de descriptores, permitiendo que un proceso escriba datos en pipefd[1] y 
otro los lea desde pipefd[0].
Uso
Estos descriptores son utilizados en llamadas a funciones de lectura y escritura, como read() y write(), permitiendo 
que los datos fluyan del proceso que escribe al proceso que lee. Si el proceso intenta leer cuando no hay datos 
disponibles, se bloqueará hasta que haya datos en el pipe. Igualmente, si el pipe está lleno, el proceso escritor 
se bloqueará hasta que el proceso lector lea y deje espacio.

iv. ¿Qué tipo de comunicación es posible con pipes?
Los pipes permiten comunicación unidireccional entre procesos. Esto significa que los datos fluyen en una sola dirección:

Comunicación unidireccional: En los pipes anónimos, un proceso escribe datos en un extremo, y otro proceso 
los lee en el otro extremo. Si se necesita comunicación bidireccional (en ambas direcciones), es necesario 
crear dos pipes: uno para enviar datos en una dirección y otro para la dirección opuesta.

Comunicación entre procesos relacionados: Los pipes anónimos solo pueden usarse entre procesos relacionados 
(por ejemplo, entre un proceso padre y su proceso hijo) porque ambos deben compartir el mismo pipe creado 
antes de la bifurcación (uso de fork()).

Comunicación entre procesos no relacionados: Esto es posible con named pipes o FIFOs, que permiten la 
comunicación entre procesos que no tienen una relación directa. Named pipes se crean con mkfifo y son 
visibles en el sistema de archivos.

Ejemplo práctico de comunicación entre procesos en C
Aquí tienes un ejemplo simple de uso de pipe() y fork() para que el proceso padre envíe datos al proceso hijo:

#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd[2];
    char mensaje[] = "Hola desde el padre";
    char buffer[100];

    // Crear el pipe
    if (pipe(fd) == -1) {
        perror("Error al crear el pipe");
        return 1;
    }

    if (fork() == 0) {  // Proceso hijo
        close(fd[1]);    // Cerrar el extremo de escritura
        read(fd[0], buffer, sizeof(buffer));  // Leer el mensaje del padre
        printf("Hijo recibió: %s\n", buffer);
        close(fd[0]);
    } else {             // Proceso padre
        close(fd[0]);    // Cerrar el extremo de lectura
        write(fd[1], mensaje, strlen(mensaje) + 1);  // Enviar mensaje al hijo
        close(fd[1]);
    }

    return 0;
}

3_ Los tiempos de retorno van a convenir que sean bajos para aquellos lotes de procesos
que necesitamos tener una respuesta rapida de lo que se este ejecutando en si mismo. Lo que son
CPU bound vamos a necesitar que el TR se lo mas bajo posible para que el termine calculo lo mas
rapido posible. En los I/O bound vamos a necesitar que el tiempo de espera sea lo mas bajo
posible, es el tiempo que el proceso que va a estar esperando cumplir su rafaga siguiente.

FCFS
• First come first served
• Cuando hay que elegir un proceso para ejecutar, se selecciona
el mas viejo
• No favorece a ning ́un tipo de procesos, pero en principio
prod ́ıamos decir que los CPU Bound terminan al comenzar su
primer r ́afaga, mientras que los I/O Bound no

SJF
• Shortest Job First
• Pol ́ıtica nonpreemptive que selecciona el proceso con la r ́afaga
m ́as corto
• Calculo basado en la ejecuci ́on previa
• Procesos cortos se colocan delante de procesos largos
• Los procesos largos pueden sufrir starvation (inanicion)

Algoritmo RR
• Round Robin
• Politica basada en un reloj
• Quantum (Q): medida que determina cuanto tiempo
podr ́a usar el procesador cada proceso:
• Pequenio: overhead de context switch
• Cuando un proceso es expulsado de la CPU es colocado al
final de la Ready Queue y se selecciona otro (FIFO circular )

• Existe un “contador” que indica las unidades de CPU en las
que el proceso se ejecuto. Cuando el mismo llega a 0 el
proceso es expulsado
• El “contador” puede ser:
• Global
• Local → PCB
• Existen dos variantes con respecto al valor inicial del
“contador” cuando un proceso es asignado a la CPU:
• Timer Variable
• Timer Fijo

Algoritmo RR - Timer Variable
• El “contador” se inicializa en Q (contador := Q) cada vez que
un proceso es asignado a la CPU
• Es el mas utilizado

Algoritmo RR - Timer Fijo
• El “contador” se inicializa en Q cuando su valor es cero
• if (contador == 0) contador = Q;
• Se puede ver como un valor de Q compartido entre los
procesos

Timer Fijo
En esta variante, el quantum es el mismo para todos los procesos.
¿Dónde debería residir el quantum?
El quantum puede residir en una estructura global del sistema operativo que gestione 
la planificación de procesos.
Razones:
Todos los procesos utilizan el mismo quantum.
Mantenerlo centralizado asegura que cualquier cambio sea uniforme y consistente para 
todos los procesos.

2. Timer Variable
En esta variante, el quantum puede variar entre procesos (por ejemplo, según su 
prioridad o tipo).
¿Dónde debería residir el quantum?
En este caso, el quantum debe ser una propiedad de cada proceso.
Se puede almacenar como un campo en la estructura de datos que representa a un proceso 
(como un PCB, Process Control Block).
Razones:
Cada proceso puede tener un quantum distinto.
Al almacenarlo en el PCB, el planificador puede acceder rápidamente al quantum del 
proceso actual.
Permite flexibilidad para adaptarse a las necesidades específicas de los procesos o 
políticas del sistema.

e_
El sistema operativo debe mantener cierta información mínima sobre cada 
proceso para administrarlo de manera adecuada. Esta información se almacena 
en una estructura de datos conocida como PCB (Process Control Block) o 
Bloque de Control de Proceso.

Información mínima que el SO debe tener sobre un proceso:

Identificación del proceso:
PID (Process Identifier): Un identificador único que distingue al proceso 
de los demás.

Estado del proceso:
Estado actual del proceso (ej. en ejecución, listo, bloqueado, terminado).

Contexto de CPU:
Valores de los registros de la CPU (contador de programa, registros 
generales, etc.) necesarios para retomar la ejecución del proceso.

Información de planificación:
Prioridad del proceso, colas de planificación, y otros datos relevantes 
para la asignación de CPU.

Información de memoria:
Detalles de la memoria asignada al proceso, como:
Dirección base y límite.

Información de las tablas de páginas o segmentos (si utiliza paginación o 
segmentación).

Información de E/S:
Archivos abiertos, dispositivos asignados, y buffers de entrada/salida.

Información de estado:
Señales recibidas.
Contadores de eventos.
Indicadores de errores.

Estructura de datos asociada: PCB
El PCB (Process Control Block) es la estructura de datos donde el SO 
almacena toda esta información. Cada proceso tiene su propio PCB y, en 
general, el PCB incluye:

Identificador del proceso (PID).
Estado del proceso.
Contador de programa (PC).
Registros de CPU.
Información de memoria (segmentos, tablas de página).
Lista de archivos abiertos.
Información de permisos y credenciales del proceso.

Ubicación del PCB
El PCB suele almacenarse en una región reservada de la memoria principal 
o en una tabla de procesos mantenida por el kernel. Esto garantiza un 
acceso rápido y eficiente al contexto de cada proceso.

El sistema operativo utiliza el PCB para:
Cambiar el contexto entre procesos (context switch).
Supervisar y controlar la ejecución de procesos.
Manejar la comunicación y sincronización entre procesos.

f_
• CPU Bound (ligados a la CPU)
• I/O Bound (ligados a entrada/salida)

Un proceso es CPU Bound si pasa la mayor parte de su tiempo utilizando la 
CPU para realizar cálculos intensivos, con pocas operaciones de 
entrada/salida.

Un proceso es I/O Bound si pasa la mayor parte de su tiempo esperando 
operaciones de entrada/salida, como leer o escribir en discos, recibir 
datos de redes, o interactuar con dispositivos externos.

g_
1. Nuevo (New)
Descripción:
El proceso está siendo creado.

2. Listo (Ready)
Descripción:
El proceso está preparado para ejecutarse, pero está esperando a que la 
CPU esté disponible.

3. Ejecutando (Running)
Descripción:
El proceso está utilizando la CPU y se encuentra en ejecución.

4. Bloqueado o Esperando (Blocked/Waiting)
Descripción:
El proceso está esperando que se complete una operación específica, como 
una entrada/salida o un evento externo.

5. Terminado (Terminated)
Descripción:
El proceso ha finalizado su ejecución (normalmente porque completó su 
tarea o fue finalizado por el sistema o el usuario).

h_ Imagen explicacion practica 4, pagina 5.

i_ 
Transición	                        Scheduler Responsable
Nuevo → Listo	                    Long-Term Scheduler
Listo → Ejecutando	                Short-Term Scheduler
Ejecutando → Listo	                Short-Term Scheduler
Ejecutando → Bloqueado	            Short-Term Scheduler
Bloqueado → Listo	                Short-Term Scheduler
Listo ↔ Suspendido	                Medium-Term Scheduler
Bloqueado ↔ Suspendido Bloqueado	Medium-Term Scheduler

6_ d) y e)
El valor del quantum debe ser cuidadosamente seleccionado según las características y objetivos del sistema:
Sistemas interactivos → Quantum pequeño.
Sistemas de alto rendimiento o cálculo intensivo → Quantum más grande.
Un valor extremadamente pequeño o extremadamente grande puede llevar a una pérdida significativa de eficiencia o de usabilidad, respectivamente.

7_ El algoritmo SRTF beneficia a los procesos interactivos o de entrada salida.

8_ 
Ventajas del algoritmo por prioridades:
Atiende procesos críticos primero, útil en sistemas en tiempo real.
Flexible, se adapta a diferentes entornos según la importancia de las tareas.
Mejora el rendimiento para procesos con deadlines estrictos.
Ideal para sistemas heterogéneos donde no todas las tareas tienen la misma relevancia.

Cuándo usarlo:
Sistemas en tiempo real.
Entornos multitarea con procesos de distinta criticidad.
Colas con prioridades naturales, como en impresoras o routers.

Cuándo no es relevante:
Cargas homogéneas donde todas las tareas son iguales en importancia.
Sistemas interactivos donde se necesita responder rápido a todos los procesos.
Cuando asignar prioridades es complejo o costoso.
Riesgo de starvation, dejando procesos de baja prioridad sin ejecutar.

 9_ 
(a) ¿Qué significa?
La inanición (o starvation) ocurre en sistemas de planificación de procesos cuando un proceso espera indefinidamente para ser ejecutado porque otros procesos, 
con mayor prioridad o preferencia, siempre son seleccionados antes. Esto sucede especialmente en sistemas donde los recursos no se asignan equitativamente o 
donde hay una alta competencia entre procesos.

En términos simples, un proceso "hambriento" nunca llega a ejecutarse debido a políticas de planificación injustas o ineficaces.

(b) ¿Cuál/es de los algoritmos vistos puede provocarla?
SJF (Shortest Job First):
Puede causar inanición si hay una secuencia continua de procesos cortos que llegan al sistema, bloqueando procesos más largos.

SRTF (Shortest Remaining Time First):
Similar al SJF, pero más propenso a inanición porque los procesos largos pueden ser constantemente interrumpidos por procesos nuevos más cortos.

Algoritmo de Prioridades:
La inanición ocurre si los procesos de baja prioridad nunca son seleccionados debido a la llegada constante de procesos con mayor prioridad.

(c) ¿Existe alguna técnica que evite la inanición para el/los algoritmos mencionados en (b)?
Sí, existen técnicas para evitar la inanición:

SJF/SRTF:
Utilizar una variante con un límite de espera máxima: Los procesos que han esperado demasiado tiempo reciben una "penalización inversa" y su prioridad aumenta 
con el tiempo, dándoles finalmente la oportunidad de ejecutarse.

Algoritmo de Prioridades:
Implementar prioridad envejecida (aging): La prioridad de un proceso aumenta progresivamente a medida que espera en la cola. Esto asegura que incluso los procesos 
de baja prioridad eventualmente serán seleccionados.

