Resolucion de la Practica 2

1) a_ Editores de texto que puede utilizar desde la línea de comandos:
    . vim
    . emacs
    . joe

b_ Los editores de texto (e.g., vi, nano, vim) son programas interactivos que permiten
crear, modificar y guardar archivos de texto. Ofrecen una interfaz más completa para
la edición de texto.
Comandos como cat, more, y less se utilizan para visualizar o manipular archivos de
texto desde la línea de comandos, pero no están diseñados para editar.

Modos de vi:

Modo normal (comandos): Es el modo por defecto al abrir vi. Aquí puedes navegar y 
ejecutar comandos.
Modo de inserción (edición): Presiona i para entrar en este modo y comenzar a editar
el texto.
Modo de comandos (guardar/salir): Presiona : (dos puntos) para entrar en este modo y 
escribir comandos como guardar y salir.

c_ Comandos básicos en vi:
    . Para entrar en modo de inserción, presiona i.
    . Para guardar y salir, primero presiona Esc para asegurarte de estar en el modo 
    normal, luego escribe :wq y presiona Enter.
    . Para salir sin guardar, presiona Esc, luego escribe :q! y presiona Enter.

Con estos pasos, podrás abrir y usar el editor vi en Linux. Si deseas un editor más 
amigable, puedes usar vim, que es una versión mejorada de vi con más características.

2) a_ 1. Se empieza a ejecutar el codigo del BIOS
    2. El BIOS ejecuta el POST
    3. El BIOS lee el sector de arranque (MBR)
    4. Se carga el gestor de arranque (MBC)
    5. El bootloader carga el kernel y el initrd
    6. Se monta el initrd como sistema de archivos raız y se
    inicializan componentes esenciales (ej.: scheduler)
    7. El Kernel ejecuta el proceso init y se desmonta el initrd
    8. Se lee el /etc/inittab
    9. Se ejecutan los scripts apuntados por el runlevel 1
    10. El final del runlevel 1 le indica que vaya al runlevel por defecto
    11. Se ejecutan los scripts apuntados por el runlevel por defecto
    12. El sistema esta listo para usarse

b_ init: el Kernel ejecuta el proceso init.
Su funcion es cargar todos los subprocesos necesarios para el
correcto funcionamiento del SO.
No tiene padre y es el padre de todos los procesos (pstree)
Es el encargado de montar los filesystems y de hacer disponible los demas dispositivos.
El proceso init posee el PID 1 y se encuentra en /sbin/ini

c_ Runlevels
• Es el modo en que arranca Linux (3 en Redhat, 2 en Debian)
• El proceso de arranque lo dividimos en niveles

d_ • Cada uno de los niveles es responsable de levantar (iniciar) o bajar (parar)
una serie de servicios.
• Se encuentran definidos en /etc/inittab
• Existen 7, y permiten iniciar un conjunto de procesos al
arranque o apagado del sistema
• Segun el estandar:
    • 0: halt (parada)
    • 1: single user mode (monousuario)
    • 2: multiuser, without NFS (modo multiusuario sin soperte de
    red)
    • 3: full multiuser mode console (modo multiusuario completo
    por consola)
    • 4: no se utiliza
    • 5: X11 (modo multiusuario completo con login grafico basado
    en X)
    • 6: reboot

No todas las distribuciones Linux respetan estrictamente estos estándares:

Distribuciones más antiguas: Distribuciones como Red Hat Enterprise Linux (RHEL), 
CentOS, Debian y sus derivados más antiguos solían seguir el esquema SysV para la 
gestión de servicios y runlevels.

Distribuciones más modernas: La mayoría de las distribuciones modernas de Linux han 
cambiado a sistemas de inicio más avanzados como systemd, que no utilizan el concepto 
tradicional de runlevels. En systemd, los runlevels se reemplazan por targets, que son 
más flexibles y ofrecen más opciones de administración de servicios y dependencias.

e_ El archivo /etc/inittab es un archivo de configuración utilizado en sistemas basados
en System V (SysV) para definir la configuración de inicialización del sistema, 
incluyendo los niveles de ejecución (runlevels). Este archivo es leído por el proceso 
init durante el arranque del sistema, que es el primer proceso en ejecutarse después
del kernel.

Finalidad del Archivo /etc/inittab
La finalidad principal del archivo /etc/inittab es:
    Definir el nivel de ejecución predeterminado del sistema al arrancar.
    Especificar los scripts y procesos que deben iniciarse o detenerse en cada nivel 
    de ejecución.
    Configurar el comportamiento del sistema para tareas específicas, como gestionar 
    la consola, las líneas de terminal virtual, y la respuesta a eventos como el 
    reinicio o apagado del sistema.
    
Información Almacenada en /etc/inittab
El archivo /etc/inittab contiene varias configuraciones críticas para la inicialización 
del sistema:
    Nivel de ejecución predeterminado (runlevel default): Especifica el runlevel que 
    el sistema debe usar por defecto al iniciar.
    Entradas de runlevel: Define los procesos que deben iniciarse, reiniciarse, o 
    detenerse cuando el sistema entra en un runlevel específico.
    Control de terminales virtuales (getty): Configura las terminales virtuales (tty) 
    en el sistema, especificando cómo y cuándo deben ser activadas.
    Eventos de control del sistema: Configura acciones para eventos especiales como 
    ctrl-alt-delete, la carga de la consola, etc.

Estructura de la Información en /etc/inittab
    El archivo /etc/inittab tiene una estructura basada en líneas de texto, donde cada
    línea sigue un formato específico con cuatro campos separados por dos puntos (:):

    id:runlevels:action:process
    id: Identificador único para la entrada (generalmente, 1-4 caracteres).
    runlevels: Especifica a qué runlevels se aplica esta entrada (uno o más runlevels, 
    por ejemplo, 2345).
    action: Acción que debe realizarse, como iniciar, esperar, reiniciar, etc.
    process: Comando o script que debe ejecutarse para esta entrada.

f_  Para cambiar de runlevel, use sudo init <Y> o sudo telinit <Y>.
    Este cambio es temporal y solo dura hasta que el sistema se reinicie.
    Para un cambio permanente, debe modificar el archivo /etc/inittab y establecer el 
    runlevel deseado como predeterminado.

g_ Los scripts RC (Run Commands) son scripts de shell que se utilizan en sistemas 
GNU/Linux basados en System V (SysV) para gestionar los procesos y servicios que se 
inician o detienen en cada nivel de ejecución (runlevel) del sistema. Estos scripts 
permiten un control detallado de qué servicios deben estar activos o inactivos 
dependiendo del estado del sistema.

La finalidad de los scripts RC es:
    Iniciar, detener, o reiniciar servicios al cambiar el nivel de ejecución (runlevel)
    del sistema.
    Gestionar el entorno del sistema al arrancar, cambiar de runlevel, o detenerse.
    Definir el comportamiento de servicios críticos del sistema (como la red, demonios
    de sistema, servicios de base de datos, etc.) en diferentes estados.

Ubicación de los Scripts RC
Los scripts RC se almacenan en directorios específicos bajo /etc:
    Directorio principal de scripts RC: /etc/init.d/ o /etc/rc.d/init.d/
    Aquí se encuentran los scripts maestros que controlan la ejecución de servicios. 
    Cada script en este directorio generalmente acepta argumentos como start, stop, 
    restart, status, etc., que se usan para gestionar el servicio correspondiente.

    Directorios de runlevels específicos: /etc/rcX.d/ (donde X es el número del runlevel,
    como 0, 1, 2, etc.)
    Estos directorios contienen enlaces simbólicos (symlinks) a los scripts maestros de
    /etc/init.d/ y determinan el orden en que los servicios deben ser iniciados o 
    detenidos para cada runlevel.

Determinación de Qué Script Ejecutar
    Cuando un sistema GNU/Linux arranca o cambia de runlevel, el proceso init lee el 
    archivo /etc/inittab para determinar el runlevel predeterminado o el runlevel al 
    que debe cambiarse. Basándose en este runlevel, el sistema:

    _ Accede al directorio correspondiente: El sistema accede al directorio /etc/rcX.d/,
    donde X es el número del runlevel.
    _ Ejecuta los scripts en ese directorio: En el directorio de runlevel específico, los 
    archivos son enlaces simbólicos a los scripts en /etc/init.d/. Los nombres de estos 
    archivos determinan si un servicio debe iniciarse o detenerse:
        . Los nombres de los enlaces simbólicos comienzan con una S (de "Start") o una 
        K (de "Kill"), seguidos de un número de dos dígitos que define el orden de 
        ejecución.
        . Por ejemplo, S01apache2 indicaría que el servicio apache2 debe iniciarse, y 
        K01apache2 indicaría que debe detenerse.

Orden de Ejecución de los Scripts
    Sí, existe un orden para llamar a los scripts RC. Este orden se determina por el 
    prefijo numérico en los enlaces simbólicos de los directorios /etc/rcX.d/:

    Los scripts que comienzan con K (Kill) se ejecutan primero cuando se cambia de 
    runlevel. Esto se hace para detener los servicios que no deben estar activos en el 
    nuevo runlevel.
    Luego, los scripts que comienzan con S (Start) se ejecutan para iniciar los servicios 
    que deben estar activos en el nuevo runlevel.
    El número que sigue a la letra K o S determina el orden de ejecución: los números 
    más bajos se ejecutan primero. Por ejemplo, S01service se ejecutará antes que 
    S02service.

Ejemplo de Estructura de Scripts RC
Supongamos que estamos en el directorio /etc/rc3.d/ (para runlevel 3):

    K01network -> ../init.d/network
    K02firewall -> ../init.d/firewall
    S01syslog -> ../init.d/syslog
    S02httpd -> ../init.d/httpd
    S03mysql -> ../init.d/mysql

Al cambiar al runlevel 3:
Primero, se ejecutan K01network y K02firewall para detener los servicios de red y 
firewall.
Luego, se ejecutan S01syslog, S02httpd, y S03mysql para iniciar el servicio de registro 
de sistema, servidor web Apache (httpd), y servidor de base de datos MySQL, respectivamente.

Conclusión
Los scripts RC son fundamentales para la gestión de servicios en sistemas basados en 
SysV, y su organización en los directorios de runlevels junto con el uso de enlaces 
simbólicos con nombres específicos permite un control preciso y ordenado del 
comportamiento del sistema en diferentes estados.

3) a_ Systemd
• Es un sistema que centraliza la administracion de demonios y
librerias del sistema
• Mejora el paralelismo de booteo
• Puede ser controlado por systemctl
• Compatible con SysV → si es llamado como init
• El demonio systemd reemplaza al proceso init → este pasa a tener PID 1
• Los runlevels son reemplazados por targets
• Al igual que con Upstart el archivo /etc/inittab no existe mas

b_ Las unidades de trabajo son denominadas Units de tipo:
• Service: controla un servicio particular (.service)
• Socket: encapsula IPC, un socket del sistema o file system
FIFO (.socket) → sockect-based activation
• Target: agrupa units o establece puntos de sincronizacion
durante el booteo (.target) → dependencia de unidades
• Snapshot: almacena el estado de un conjunto de unidades que
puede ser restablecido mas tarde (.snapshot)
• etc.
• Las units pueden tener dos estados → active o inactive

c_ El comando systemctl es una herramienta de línea de comandos utilizada en sistemas 
Linux que utilizan systemd como su sistema de inicialización (init system). systemctl 
es el comando principal para gestionar y controlar los servicios y unidades del sistema 
que están bajo el control de systemd. Este comando permite administrar los servicios, 
configurar el comportamiento de arranque, consultar el estado del sistema, reiniciar 
el sistema, entre muchas otras tareas relacionadas con la administración del sistema.

d_ Target: agrupa units o establece puntos de sincronizacion
durante el booteo (.target) → dependencia de unidades

El concepto de target se refiere a una unidad especial que agrupa y organiza otros 
servicios y unidades para lograr un estado específico del sistema. Un target es una 
forma de definir y agrupar un conjunto de servicios y otros targets que deben estar 
activos al mismo tiempo.
Los targets en systemd son similares a los runlevels del sistema de inicialización 
System V (SysV), pero son más flexibles y potentes porque pueden definir estados más 
específicos y no están limitados a un número fijo de niveles de ejecución. Además, un 
target puede ser utilizado como un punto de sincronización en el proceso de arranque o 
apagado del sistema, agrupando unidades relacionadas.

e_ El comando pstree en Linux se utiliza para mostrar los procesos en ejecución en forma 
de un árbol jerárquico. Al ejecutar pstree, se puede observar la estructura de los 
procesos del sistema, mostrando la relación de padre-hijo entre los procesos.
Árbol de Procesos: pstree muestra todos los procesos en el sistema de manera jerárquica, 
comenzando desde el proceso raíz (init o systemd), que es el primer proceso que se 
ejecuta al arrancar el sistema. Todos los demás procesos son descendientes de este 
proceso.

4) a_ La información de los usuarios estan en la ruta /etc/passwd.

b_ Las siglas UID y GID en un sistema GNU/Linux hacen referencia a identificadores que 
se utilizan para gestionar y asignar permisos a los usuarios y grupos en el sistema.

UID (User Identifier) es un número único asignado a cada usuario en el sistema. Este 
identificador se utiliza para representar al usuario dentro del sistema operativo y para 
gestionar los permisos y la propiedad de los archivos y procesos.
Detalles Importantes sobre UID:

    Cada usuario tiene un UID único. Por ejemplo, el usuario root tiene un UID de 0.
    Los UIDs típicos de los usuarios normales comienzan desde 1000 en la mayoría de las 
    distribuciones de Linux, mientras que los UIDs por debajo de 1000 suelen estar 
    reservados para cuentas del sistema (como nobody, daemon, etc.).
    Los UIDs están definidos en el archivo /etc/passwd.

GID (Group Identifier) es un número único asignado a cada grupo en el sistema. Los 
grupos se utilizan para definir conjuntos de usuarios que comparten permisos comunes 
para acceder a archivos, directorios, o ejecutar comandos.
Detalles Importantes sobre GID:
    Similar al UID, cada grupo tiene un GID único.
    Los GIDs para grupos de usuarios suelen comenzar también desde 1000, mientras que 
    los GIDs por debajo de 1000 están reservados para grupos del sistema.
    Los GIDs están definidos en el archivo /etc/group.

¿Pueden coexistir UIDs iguales en un sistema GNU/Linux?
    En un sistema GNU/Linux estándar:
    No es posible que dos usuarios diferentes tengan el mismo UID de manera funcional, 
    ya que el UID debe ser único para cada usuario para evitar conflictos de permisos 
    y propiedad.

c_ • root: es el administrador del sistema (superusuario).
El usuario root en GNU/Linux es el superusuario del sistema, con privilegios completos 
y sin restricciones. Es el usuario más poderoso en el sistema operativo, capaz de 
realizar cualquier operación, como gestionar archivos del sistema, instalar o desinstalar 
software, cambiar configuraciones del sistema, y administrar otros usuarios.
UID de root: El usuario root siempre tiene el UID 0 en sistemas GNU/Linux. Este UID está 
reservado exclusivamente para el superusuario.
No puede existir otro usuario llamado root, pero sí pueden existir múltiples usuarios 
con el UID 0, aunque esta no es una práctica segura ni recomendable. Para una 
administración más segura y controlada, se recomienda utilizar sudo para tareas que 
requieran permisos elevados.

d_ Paso 1: Crear el usuario iso2017 con un directorio home personalizado
    Abre una terminal.
    Para agregar un nuevo usuario llamado iso2017 con el directorio home especificado en
    /home/iso_2017, usa el siguiente comando:
    
    sudo useradd -m -d /home/iso_2017 iso2017

Paso 2: Crear el grupo catedra (si no existe)
    Para verificar si el grupo catedra ya existe, puedes usar:

    getent group catedra

    Si el grupo no existe, créalo con:

    sudo groupadd catedra

Paso 3: Agregar el usuario iso2017 al grupo catedra

    sudo usermod -aG catedra iso2017

Paso 4: Crear un archivo en el directorio personal del usuario iso2017 sin iniciar 
sesión como ese usuario
Crea un archivo en el directorio home del usuario iso2017 que le pertenezca. 
Puedes hacerlo con el siguiente comando:

    sudo touch /home/iso_2017/archivo.txt
    sudo chown iso2017:iso2017 /home/iso_2017/archivo.txt

Paso 5: Borrar el usuario iso2017 y verificar que no queden registros
Para eliminar el usuario iso2017 y su directorio home, utiliza:

    sudo userdel -r iso2017

Para asegurarte de que no queden registros del usuario en los archivos de información 
de usuarios y grupos, puedes usar los siguientes comandos:
    
    Verifica que no exista en /etc/passwd:
    getent passwd iso2017

    Verifica que no exista en /etc/group:
    getent group catedra | grep iso2017

Si ninguno de estos comandos devuelve información relacionada con iso2017, habrás 
verificado que no quedan registros del usuario ni en los archivos de información de 
usuarios ni en los grupos.

e_ 
1. useradd o adduser
   Funcionalidad:
   - useradd: Es un comando de bajo nivel para agregar usuarios. Se utiliza para crear una nueva cuenta de usuario en el sistema.
   - adduser: Es un script de Perl que utiliza useradd en el fondo, pero proporciona una interfaz más amigable para la creación de usuarios, solicitando información de manera interactiva.

   Principales Parámetros de useradd:
   - -m: Crea un directorio de inicio (home) para el usuario.
   - -d /ruta/del/home: Especifica el directorio home del usuario.
   - -s /bin/bash: Establece el shell de inicio de sesión del usuario.
   - -g grupo: Asigna un grupo principal al usuario.
   - -G grupos: Asigna uno o más grupos secundarios al usuario.
   - -u UID: Especifica un UID (User ID) para el usuario.
   - -c "comentario": Agrega un comentario (normalmente el nombre completo del usuario).

   Ejemplo:
   sudo useradd -m -d /home/usuario -s /bin/bash -g grupo_principal -G grupo_secundario usuario

2. usermod
   Funcionalidad:
   - Modifica los atributos de una cuenta de usuario existente.

   Principales Parámetros:
   - -l nuevo_nombre: Cambia el nombre del usuario.
   - -d /nueva/ruta/home -m: Cambia el directorio de inicio del usuario y mueve el contenido.
   - -s /bin/nuevo_shell: Cambia el shell de inicio de sesión del usuario.
   - -g nuevo_grupo: Cambia el grupo principal del usuario.
   - -G nuevos_grupos: Cambia los grupos secundarios del usuario.
   - -aG grupo: Agrega el usuario a un grupo secundario (sin eliminar otros grupos secundarios existentes).

   Ejemplo:
   sudo usermod -aG grupo_adicional usuario

3. userdel
   Funcionalidad:
   - Elimina una cuenta de usuario del sistema.

   Principales Parámetros:
   - -r: Elimina el directorio de inicio del usuario y su correo.

   Ejemplo:
   sudo userdel -r usuario

4. su
   Funcionalidad:
   - Cambia el usuario de sesión actual a otro usuario. Por defecto, cambia a root si no se especifica ningún usuario.

   Principales Parámetros:
   - -: Inicia un nuevo shell de inicio de sesión.
   - -c 'comando': Ejecuta un comando con privilegios del usuario especificado y luego vuelve al usuario original.

   Ejemplo:
   su - usuario

5. groupadd
   Funcionalidad:
   - Crea un nuevo grupo en el sistema.

   Principales Parámetros:
   - -g GID: Especifica un GID (Group ID) para el grupo.
   - -r: Crea un grupo del sistema.

   Ejemplo:
   sudo groupadd nombre_grupo

6. who
   Funcionalidad:
   - Muestra información sobre los usuarios que están actualmente conectados al sistema.

   Principales Parámetros:
   - -a: Muestra toda la información disponible.
   - -q: Muestra un resumen de los usuarios conectados.
   - -u: Muestra información sobre el tiempo de inactividad del usuario.

   Ejemplo:
   who -a

7. groupdel
   Funcionalidad:
   - Elimina un grupo del sistema.

   Ejemplo:
   sudo groupdel nombre_grupo

8. passwd
   Funcionalidad:
   - Cambia la contraseña de un usuario o actualiza la información de autenticación.

   Principales Parámetros:
   - -l: Bloquea la cuenta del usuario.
   - -u: Desbloquea la cuenta del usuario.
   - -d: Elimina la contraseña del usuario, permitiendo el acceso sin contraseña.
   - --stdin: Permite pasar la nueva contraseña desde la entrada estándar.

   Ejemplo:
   sudo passwd usuario


5) a_ Permisos
• Se aplican a directorios y archivos
• Existen 3 tipos de permisos y se basan en una notacion octal:
    Permiso     Valor   Octal
    Lectura     R       4
    Escritura   W       2
    Ejecucion   X       1

• Se aplican sobre los usuarios:
• Usuario: permisos del due ̃no → U
• Usuario: permisos del grupo → G
• Usuario: permisos de otros usuario → O

b_ En GNU/Linux, los comandos chmod, chown y chgrp se utilizan para gestionar los 
permisos y la propiedad de archivos y directorios. A continuación, se describe la 
funcionalidad y los parámetros de cada comando:

1. chmod (Change Mode)
El comando chmod se utiliza para cambiar los permisos de un archivo o directorio. 
Los permisos se pueden configurar utilizando el sistema simbólico o el numérico (octal).

    Sintaxis básica: chmod [opciones] modo archivo

    Modos de permisos:
        Simbólico: u (usuario), g (grupo), o (otros), a (todos), con +, -, = para 
        añadir, quitar o establecer permisos.
        Numérico: Cada permiso se representa como un número: r (4), w (2), x (1).
        Ejemplo: chmod 755 archivo.txt asigna permisos de lectura, escritura y 
        ejecución para el usuario, y permisos de lectura y ejecución para el grupo y 
        otros.

2. chown (Change Owner)
El comando chown cambia el propietario de un archivo o directorio.

    Sintaxis básica: chown [opciones] usuario[:grupo] archivo

    Parámetros:
    usuario: El nuevo propietario del archivo.
    grupo: El nuevo grupo propietario (opcional).
    Ejemplo: chown usuario archivo.txt cambia el propietario de archivo.txt a usuario.

    Ejemplo con grupo: chown usuario:grupo archivo.txt cambia el propietario a usuario 
    y el grupo a grupo.

3. chgrp (Change Group)
El comando chgrp cambia el grupo propietario de un archivo o directorio.

    Sintaxis básica: chgrp [opciones] grupo archivo
    Parámetros:
    grupo: El nuevo grupo propietario del archivo.
    Ejemplo: chgrp grupo archivo.txt cambia el grupo propietario de archivo.txt a grupo.

Resumen
Estos comandos son fundamentales para la gestión de permisos y propiedad en sistemas 
Linux. chmod modifica los permisos de acceso, chown cambia el propietario de archivos 
y directorios, y chgrp cambia el grupo propietario.

c_  chmod (Change Mode)
    Modos de permisos:
        Simbólico: u (usuario), g (grupo), o (otros), a (todos), con +, -, = para 
        añadir, quitar o establecer permisos.
        Numérico: Cada permiso se representa como un número: r (4), w (2), x (1).
        Ejemplo: chmod 755 archivo.txt asigna permisos de lectura, escritura y 
        ejecución para el usuario, y permisos de lectura y ejecución para el grupo y 
        otros.

d_ En sistemas GNU/Linux, los permisos de archivos y directorios son administrados 
estrictamente por el sistema operativo, lo que generalmente impide que un usuario 
acceda a un archivo para el cual no tiene permisos. Sin embargo, existen ciertas 
situaciones y métodos especiales que podrían permitir a un usuario sin permisos 
explícitos acceder a un archivo. Algunos de estos casos incluyen:

    Usuario Root (superusuario): El superusuario o root en Linux tiene todos los 
privilegios del sistema, lo que le permite acceder a cualquier archivo, 
independientemente de los permisos establecidos.

    Permisos SUID, SGID y Sticky Bit:
    SUID (Set User ID): Permite que un archivo sea ejecutado con los privilegios del 
propietario del archivo, no del usuario que lo ejecuta. Esto puede permitir que un 
usuario ejecute un archivo con permisos adicionales.
    SGID (Set Group ID): Similar a SUID, pero otorga permisos del grupo propietario del 
    archivo.
    Sticky Bit: Generalmente usado en directorios para permitir que solo los 
    propietarios de archivos específicos puedan borrarlos o renombrarlos, incluso si 
    otros tienen permisos de escritura en el directorio.

    Acceso mediante programas con privilegios elevados: Algunos programas o servicios 
    ejecutados con permisos elevados (como sudo o doas) pueden otorgar acceso temporal 
    a archivos.

    Errores de configuración de permisos: A veces, errores de configuración de permisos 
    en archivos o directorios pueden permitir el acceso no intencionado.

Pruebas de Acceso a Archivos sin Permisos

1. Crear un Archivo con Permisos Restringidos
Primero, crearemos un archivo con permisos restringidos para cualquier usuario que no 
sea el propietario:

    touch archivo_restringido.txt
    chmod 700 archivo_restringido.txt  # Solo el propietario tiene permisos de lectura, escritura y ejecución
    ls -l archivo_restringido.txt

El resultado mostrará algo similar a:

    -rwx------ 1 usuario usuario 0 fecha archivo_restringido.txt

Esto indica que solo el propietario (usuario) tiene permisos completos (lectura, 
escritura, ejecución).

2. Intentar Acceso como Otro Usuario
Cambie a otro usuario o cree uno nuevo para realizar pruebas:

    sudo adduser usuario_prueba
    su - usuario_prueba

Como usuario_prueba, intente acceder al archivo:

    cat /ruta/a/archivo_restringido.txt

Esto debería devolver un "Permission denied".

3. Acceso con sudo
Intente acceder al archivo utilizando sudo para simular el acceso como superusuario:

    sudo cat /ruta/a/archivo_restringido.txt

Esto debería funcionar y mostrar el contenido del archivo porque el superusuario tiene 
permisos para acceder a todos los archivos.

e_ En sistemas operativos basados en UNIX, como GNU/Linux, los conceptos de "full path 
name" (ruta absoluta) y "relative path name" (ruta relativa) se refieren a dos maneras 
diferentes de especificar la ubicación de archivos y directorios en el sistema de 
archivos.

1. Full Path Name (Ruta Absoluta)
Una ruta absoluta es una ruta que especifica la ubicación completa de un archivo o 
directorio en el sistema de archivos, comenzando desde el directorio raíz (/). 
Siempre comienza con una barra diagonal (/), que representa la raíz del sistema de 
archivos. Este tipo de ruta es independiente del directorio actual; no importa en qué 
directorio se encuentre el usuario, la ruta absoluta siempre apunta al mismo archivo 
o directorio.

Ejemplos de Ruta Absoluta:
Archivo en el directorio /home:

/home/usuario/documentos/archivo.txt

Este es el camino completo desde el directorio raíz / hasta el archivo archivo.txt en 
el directorio documentos del usuario usuario.
Archivo en el directorio /etc:

/etc/hostname

Esta es la ruta absoluta al archivo hostname en el directorio /etc, que es un 
directorio común para archivos de configuración del sistema.

2. Relative Path Name (Ruta Relativa)
Una ruta relativa especifica la ubicación de un archivo o directorio en relación con 
el directorio de trabajo actual. No comienza con una barra diagonal (/); en su lugar, 
puede comenzar con el nombre de un directorio, un punto (.) para representar el 
directorio actual, o dos puntos (..) para representar el directorio padre (el directorio 
un nivel más arriba).

Las rutas relativas son útiles cuando estás trabajando en un directorio específico y 
deseas acceder a archivos o subdirectorios dentro de ese directorio o en su estructura 
jerárquica.

Ejemplos de Ruta Relativa:
Archivo en un subdirectorio del directorio actual:
Si el directorio de trabajo actual es /home/usuario, la ruta relativa a un archivo 
llamado archivo.txt en el subdirectorio documentos sería:
documentos/archivo.txt

Archivo en el directorio padre:
Si el directorio de trabajo actual es /home/usuario/documentos y deseas acceder a un 
archivo archivo.txt en el directorio padre (/home/usuario), usarías:
../archivo.txt
Aquí, .. representa el directorio padre.

Archivo en el directorio actual:
Si el directorio de trabajo actual contiene un archivo llamado archivo.txt, la ruta 
relativa sería simplemente:
./archivo.txt
Aquí, . representa el directorio actual. Sin embargo, es común omitir ./ y simplemente 
escribir archivo.txt.

f_ Con el comando "pwd" (print working directory) se puede determinar en que directorio
se encuentra actualmente.
Existe una forma de ingresar a tu directorio personal sin tener que escribir toda la 
ruta. Puedes usar el carácter ~ (tilde) para representar tu directorio personal.
Por ejemplo, si tu directorio personal es /home/usuario, simplemente puedes escribir:

    cd ~

Tambien puedes utilizar la misma idea para acceder a subdirectorios o rutas relativas. 
El carácter ~ representa el directorio personal, por lo que si deseas acceder a un 
subdirectorio dentro de tu directorio personal, puedes usar:

Ejemplo: Para cambiar al subdirectorio Documentos dentro de tu directorio personal:

    cd ~/Documentos

g_ 
1. cd (Change Directory)
    Cambia el directorio de trabajo actual.
    Uso básico: cd [directorio]
    Parámetros comunes:
    cd sin argumentos te lleva al directorio personal del usuario.
    cd .. sube un nivel en la jerarquía de directorios.
    cd - cambia al último directorio visitado.
    Ejemplo: cd /home/usuario/Documentos

2. umount (Unmount File System)
    Desmonta un sistema de archivos.
    Uso básico: umount [opciones] <dispositivo|punto de montaje>
    Parámetros comunes:
    -l o --lazy: Desmonta de forma "perezosa"; detiene nuevas referencias al sistema de archivos pero espera hasta que se liberen las referencias actuales.
    -f o --force: Fuerza el desmontaje (útil para sistemas de archivos en red).
    -v o --verbose: Modo detallado; muestra información adicional.
    Ejemplo: umount /mnt/usb

3. mkdir (Make Directory)
    Crea uno o más directorios nuevos.
    Uso básico: mkdir [opciones] <nombre_del_directorio>
    Parámetros comunes:
    -p o --parents: Crea directorios de forma recursiva; no genera error si ya existen.
    -v o --verbose: Muestra un mensaje para cada directorio creado.
    Ejemplo: mkdir -p /home/usuario/nuevo/directorio

4. du (Disk Usage)
    Muestra el uso del espacio en disco de archivos y directorios.
    Uso básico: du [opciones] [archivo/directorio]
    Parámetros comunes:
    -h o --human-readable: Muestra tamaños en un formato legible (KB, MB, GB).
    -s o --summarize: Muestra solo el tamaño total.
    -a o --all: Incluye archivos además de directorios.
    -d N o --max-depth=N: Muestra el uso de espacio en disco hasta un nivel de profundidad N.
    Ejemplo: du -h /home/usuario

5. rmdir (Remove Directory)
    Elimina directorios vacíos.
    Uso básico: rmdir [opciones] <nombre_del_directorio>
    Parámetros comunes:
    --ignore-fail-on-non-empty: No genera error si el directorio no está vacío.
    -p o --parents: Elimina el directorio especificado y su cadena de directorios padres si están vacíos.
    Ejemplo: rmdir /home/usuario/directorio_vacio

6. df (Disk Free)
    Muestra el espacio disponible y usado en los sistemas de archivos.
    Uso básico: df [opciones] [sistema_de_archivos|directorio]
    Parámetros comunes:
    -h o --human-readable: Muestra tamaños en un formato legible (KB, MB, GB).
    -T o --print-type: Muestra el tipo de sistema de archivos.
    -i o --inodes: Muestra información sobre los inodos en lugar del uso en bloques.
    Ejemplo: df -h /home

7. mount (Mount File System)
    Montaje de sistemas de archivos.
    Uso básico: mount [opciones] <dispositivo> <punto_de_montaje>
    Parámetros comunes:
    -t o --type: Especifica el tipo de sistema de archivos.
    -o o --options: Especifica opciones de montaje adicionales, como ro (solo lectura), rw (lectura/escritura), noexec (sin ejecutar archivos).
    -v o --verbose: Modo detallado.
    Ejemplo: mount -t ext4 /dev/sda1 /mnt/disco

8. ln (Link)
    Crea enlaces a archivos.
    Uso básico: ln [opciones] <archivo_origen> <archivo_destino>
    Parámetros comunes:
    -s o --symbolic: Crea un enlace simbólico (soft link) en lugar de un enlace duro (hard link).
    -f o --force: Sobrescribe archivos de destino existentes.
    -v o --verbose: Modo detallado.
    Ejemplo: ln -s /home/usuario/archivo.txt /home/usuario/enlace.txt

9. ls (List Directory Contents)
    Lista archivos y directorios.
    Uso básico: ls [opciones] [archivo/directorio]
    Parámetros comunes:
    -l: Muestra detalles en formato largo (permisos, propietario, tamaño, etc.).
    -a o --all: Incluye archivos ocultos (los que empiezan con .).
    -h o --human-readable: Muestra tamaños en formato legible.
    -R o --recursive: Lista subdirectorios de forma recursiva.
    Ejemplo: ls -la /home/usuario

10. pwd (Print Working Directory)
    Muestra el directorio de trabajo actual.
    Uso básico: pwd
    Parámetros comunes:
    -L o --logical: Muestra el directorio actual siguiendo enlaces simbólicos.
    -P o --physical: Muestra el directorio actual evitando enlaces simbólicos.
    Ejemplo: pwd

11. cp (Copy)
    Copia archivos y directorios.
    Uso básico: cp [opciones] <archivo_origen> <archivo_destino>
    Parámetros comunes:
    -r o --recursive: Copia directorios de forma recursiva.
    -i o --interactive: Pide confirmación antes de sobrescribir.
    -v o --verbose: Modo detallado.
    -u o --update: Copia solo cuando el archivo de origen es más nuevo que el archivo de destino o cuando el archivo de destino no existe.
    Ejemplo: cp -r /home/usuario/Documentos /home/usuario/Respaldo

12. mv (Move)
    Mueve o renombra archivos y directorios.
    Uso básico: mv [opciones] <archivo_origen> <archivo_destino>
    Parámetros comunes:
    -i o --interactive: Pide confirmación antes de sobrescribir.
    -v o --verbose: Modo detallado.
    -u o --update: Mueve solo cuando el archivo de origen es más nuevo que el archivo de destino o cuando el archivo de destino no existe.
    Ejemplo: mv /home/usuario/archivo.txt /home/usuario/Documentos/archivo.txt

6) a_ Un proceso es una instancia de un programa en ejecución. En sistemas operativos 
como GNU/Linux, un proceso es una entidad que contiene la información necesaria para 
ejecutar un programa, incluyendo su código, datos, variables, y recursos del sistema, 
como memoria y tiempo de CPU. Cada proceso se ejecuta de manera aislada, lo que 
garantiza que los problemas en un proceso no afecten directamente a otros.

PID (Process ID): Es el "Identificador de Proceso" y es un número único que el sistema 
operativo asigna a cada proceso cuando se crea. Este número se utiliza para identificar 
y gestionar procesos en el sistema.

PPID (Parent Process ID): Es el "Identificador de Proceso Padre" y hace referencia al 
proceso que creó (o inició) el proceso actual. Cada proceso tiene un proceso padre, 
excepto el proceso inicial (generalmente el proceso init o systemd en sistemas 
GNU/Linux), que tiene un PPID de 0.

Todos los procesos en GNU/Linux tienen un PID y un PPID. Esto es fundamental para el 
modelo de procesos de Unix y Linux. Cuando un proceso es creado por otro proceso, 
se le asigna automáticamente un PID único y se establece su PPID correspondiente.

El PID es esencial para que el sistema operativo pueda rastrear y gestionar procesos. 
De igual forma, el PPID permite mantener la jerarquía de procesos y relaciones de padre 
e hijo, facilitando la terminación de procesos y otras operaciones relacionadas.

Además del PID y el PPID, un proceso en GNU/Linux tiene muchos otros atributos, algunos 
de los cuales incluyen:

UID (User ID) y GID (Group ID): El identificador de usuario y grupo que posee el proceso. 
Estos identificadores determinan los permisos de acceso que tiene el proceso sobre los 
archivos y recursos del sistema.

Estado del proceso: Puede ser:
    Running (R): El proceso está en ejecución.
    Sleeping (S): El proceso está en espera de un evento.
    Stopped (T): El proceso ha sido detenido.
    Zombie (Z): El proceso ha terminado, pero aún no ha sido limpiado del sistema.

Prioridad (PRI) y valor de nice (NI): Determinan la prioridad del proceso para la 
planificación del CPU. La prioridad es un número que determina la urgencia con la que 
un proceso debe ser ejecutado.

Tiempo de CPU (TIME): El tiempo de CPU que el proceso ha consumido desde que se inició.

Contador de páginas y memoria: Información sobre el uso de memoria, incluyendo el 
tamaño de la memoria virtual del proceso (VIRT), el tamaño de la memoria residente 
(RES), y el tamaño de la memoria compartida (SHR).

Puntero de instrucción (PC): Dirección de la siguiente instrucción que debe ejecutar 
el proceso.

Entorno del proceso: Variables de entorno que el proceso utiliza, como PATH, HOME, y 
otras variables definidas por el usuario o el sistema.

Descriptor de archivos: Cada proceso tiene una tabla de descriptores de archivos 
abiertos, que son identificadores para los archivos abiertos, sockets, y otros recursos.

Señales: Los procesos pueden recibir y enviar señales, que son formas de notificación 
o interrupción del sistema, como SIGKILL, SIGSTOP, SIGTERM, etc.

b_ Para ver los procesos que están en ejecución en un sistema GNU/Linux, se pueden 
utilizar varios comandos que proporcionan información detallada sobre los procesos. 
Algunos de los comandos más comunes son:

1. ps (Process Status)
El comando ps muestra información sobre los procesos en ejecución en el sistema. Es uno 
de los comandos más utilizados para listar procesos y permite mostrar diferentes 
niveles de detalles según las opciones proporcionadas.

Uso básico: ps
Parámetros comunes:
    ps aux: Muestra todos los procesos en ejecución en el sistema (incluidos los de otros 
    usuarios) en un formato detallado. La opción a muestra procesos de todos los usuarios, 
    u muestra detalles de cada proceso, y x muestra procesos que no tienen un terminal 
    asociado.
    ps -ef: Muestra todos los procesos en un formato de estilo BSD, incluyendo información 
    sobre el PPID y más detalles.

2. top
El comando top muestra un resumen en tiempo real de los procesos que están consumiendo 
más recursos del sistema, como la CPU y la memoria. Proporciona una vista dinámica que 
se actualiza automáticamente cada pocos segundos.
    Uso básico: top
    Características:
    Muestra los procesos ordenados por uso de CPU de forma predeterminada.
    Se puede interactuar con la vista en tiempo real, cambiando la ordenación, filtrando 
    procesos, o matando procesos directamente desde la interfaz.
    htop es una versión mejorada de top que proporciona una interfaz más amigable e 
    interactiva.

3. htop
El comando htop es una versión interactiva y visualmente mejorada de top. Ofrece una 
interfaz de usuario más amigable, permite utilizar el teclado para seleccionar y 
gestionar procesos fácilmente, y muestra información en colores para distinguir entre 
los diferentes tipos de procesos y recursos utilizados.
    Uso básico: htop
    Características:
    Muestra una lista de procesos en ejecución con información detallada.
    Permite navegar y filtrar procesos, buscar procesos específicos y realizar acciones 
    sobre ellos, como enviar señales para terminarlos.
    No está instalado por defecto en todas las distribuciones de GNU/Linux, pero se 
    puede instalar fácilmente desde los repositorios.

4. pstree
El comando pstree muestra los procesos en ejecución en una estructura jerárquica o de 
árbol. Es útil para ver la relación entre procesos padre e hijo.
    Uso básico: pstree
    Parámetros comunes:
    pstree -p: Muestra el árbol de procesos con sus PIDs.
    pstree -u: Muestra los procesos con los nombres de los usuarios que los poseen.

5. pgrep
El comando pgrep busca procesos que coinciden con un patrón determinado y devuelve sus 
PIDs. Es útil para encontrar procesos específicos sin necesidad de usar comandos más 
complejos.
    Uso básico: pgrep <nombre_del_proceso>
    Ejemplo: pgrep ssh para encontrar procesos relacionados con SSH.

6. pidof
El comando pidof devuelve el PID de un proceso en ejecución dado su nombre. Es similar 
a pgrep pero se utiliza principalmente para buscar un solo proceso.
    Uso básico: pidof <nombre_del_proceso>
    Ejemplo: pidof apache2 para encontrar el PID del proceso de Apache.

7. watch
Aunque no es específicamente para listar procesos, el comando watch puede usarse junto 
con ps o pgrep para monitorear procesos en tiempo real.
    Uso básico: watch <comando>
    Ejemplo: watch -n 1 'ps aux | grep nginx' para monitorear en tiempo real los procesos 
    relacionados con Nginx.

8. systemctl
En sistemas basados en systemd, el comando systemctl puede mostrar información sobre 
los servicios (que son procesos administrados por systemd).
    Uso básico: systemctl status
    Parámetros comunes:
    systemctl status <nombre_del_servicio>: Muestra el estado de un servicio específico.
    systemctl list-units --type=service: Lista todos los servicios activos.

c_ 
Background (Segundo Plano)
Un proceso que se ejecuta en background es aquel que no tiene el control directo de la 
terminal y se ejecuta en segundo plano, permitiendo al usuario seguir utilizando la 
terminal para otros comandos.

Foreground (Primer Plano)
Un proceso que se ejecuta en foreground es aquel que tiene el control directo de la 
terminal. Mientras un proceso está en primer plano, la terminal no puede aceptar otros 
comandos hasta que el proceso termine o sea enviado al background.

d_ Ejecutar un Proceso en Segundo Plano
Para ejecutar un comando en segundo plano, añade un & al final del comando. Por ejemplo:

    long_running_command &

Esto ejecutará long_running_command en segundo plano, permitiéndote seguir usando la 
terminal para otros comandos.

Pasar un Proceso de Fondo a Primer Plano
Para llevar un proceso que está en segundo plano al primer plano, usa el comando fg. 
Primero, debes identificar el número de trabajo del proceso en segundo plano, que 
puedes encontrar con el comando jobs:

    jobs

Esto mostrará una lista de trabajos en segundo plano con un número de trabajo 
(por ejemplo, [1]).

Luego, usa el comando fg seguido del número de trabajo para llevar el proceso al 
primer plano:

    fg %1

Aquí, %1 es el número del trabajo que quieres traer al primer plano.

Pasar un Proceso de Primer Plano a Fondo
Si tienes un proceso en primer plano y deseas enviarlo a segundo plano, primero debes 
suspenderlo usando Ctrl + Z. Esto detendrá el proceso y lo moverá a segundo plano, 
pero lo dejará en estado de suspensión.

Luego, usa el comando bg para reanudar el proceso en segundo plano:

    bg %1

Donde %1 es el número del trabajo.

e_ El pipe (|) es un operador en sistemas Unix-like (como Linux y macOS) que se utiliza 
para encadenar comandos, pasando la salida de un comando directamente como entrada al 
siguiente comando. Esto permite crear flujos de trabajo complejos y realizar 
procesamiento en varios pasos de manera eficiente.

Finalidad del Pipe
El propósito principal del pipe es redirigir la salida estándar (stdout) de un comando 
a la entrada estándar (stdin) de otro comando. Esto facilita la combinación de 
herramientas y comandos para realizar tareas más complejas.

Ejemplos de Utilización
Contar el Número de Archivos en un Directorio
Para contar el número de archivos en un directorio, puedes usar ls para listar los 
archivos y wc -l para contar el número de líneas:

    ls | wc -l

Aquí, ls lista los archivos y directorios en el directorio actual, y wc -l cuenta el 
número de líneas en la salida de ls, que corresponde al número de archivos y directorios.

Buscar Texto en Archivos
Puedes usar grep para buscar texto específico dentro de archivos. Por ejemplo, para 
buscar la palabra "error" en los archivos de un directorio:

    cat * | grep "error"

Aquí, cat * concatena y muestra el contenido de todos los archivos en el directorio, 
y grep "error" filtra las líneas que contienen la palabra "error".

Ordenar y Filtrar Datos
Supongamos que tienes una lista de nombres en un archivo y quieres ordenar los nombres 
alfabéticamente y luego eliminar los duplicados. Puedes usar sort para ordenar y uniq 
para eliminar duplicados:

    cat nombres.txt | sort | uniq

Aquí, cat nombres.txt muestra el contenido del archivo, sort ordena las líneas, y uniq 
elimina las líneas duplicadas.

f_ La redirección en sistemas Unix-like permite enviar la entrada o salida de comandos 
a diferentes lugares, como archivos o dispositivos, en lugar de la entrada/salida 
estándar (stdin/stdout). La redirección facilita la captura y manipulación de datos 
y resultados de comandos.

Tipos de Redirección

Redirección de Salida Estándar (stdout)
Símbolo: >
Finalidad: Redirige la salida estándar de un comando a un archivo, sobrescribiendo el 
contenido del archivo si ya existe.
Ejemplo:
echo "Hola Mundo" > archivo.txt
Aquí, echo "Hola Mundo" envía la cadena "Hola Mundo" a archivo.txt, sobrescribiendo 
cualquier contenido previo.

Símbolo: >>
Finalidad: Redirige la salida estándar de un comando a un archivo, añadiendo el 
contenido al final del archivo en lugar de sobrescribirlo.
Ejemplo:
    echo "Otra línea" >> archivo.txt
Aquí, echo "Otra línea" añade la cadena "Otra línea" al final de archivo.txt sin 
borrar el contenido existente.

Redirección de Entrada Estándar (stdin)
Símbolo: <
Finalidad: Redirige la entrada estándar de un comando desde un archivo.
Ejemplo:
    sort < archivo.txt
Aquí, sort toma su entrada desde archivo.txt en lugar de la entrada estándar del 
teclado.

Redirección de Error Estándar (stderr)
Símbolo: 2>
Finalidad: Redirige la salida de errores (stderr) de un comando a un archivo, 
sobrescribiendo el contenido del archivo si ya existe.
Ejemplo:
    ls /no_existe 2> errores.txt
Aquí, cualquier mensaje de error generado por ls se guarda en errores.txt.

Símbolo: 2>>
Finalidad: Redirige la salida de errores (stderr) de un comando a un archivo, 
añadiendo el contenido al final del archivo en lugar de sobrescribirlo.
Ejemplo:
    ls /no_existe 2>> errores.txt
Aquí, cualquier mensaje de error generado por ls se añade al final de errores.txt.

Redirección Combinada de Salida y Error
Símbolo: &>
Finalidad: Redirige tanto la salida estándar (stdout) como los errores estándar 
(stderr) a un archivo, sobrescribiendo el contenido del archivo si ya existe.
Ejemplo:
    comando > salida_y_errores.txt 2>&1
Aquí, tanto la salida estándar como los errores estándar del comando se redirigen a 
salida_y_errores.txt.

Símbolo: &>>
Finalidad: Redirige tanto la salida estándar como los errores estándar a un archivo, 
añadiendo el contenido al final del archivo en lugar de sobrescribirlo.
Ejemplo:
    comando >> salida_y_errores.txt 2>&1
Aquí, tanto la salida estándar como los errores estándar del comando se añaden al 
final de salida_y_errores.txt.

Redirección de Salida a un Comando (Tubería)
Símbolo: |
Finalidad: Redirige la salida estándar de un comando como entrada para otro comando.
Ejemplo:
    cat archivo.txt | grep "texto"
Aquí, cat archivo.txt muestra el contenido de archivo.txt, y grep "texto" busca el 
texto "texto" en la salida de cat.

g_ El comando kill en sistemas Unix-like se utiliza para enviar señales a procesos en 
ejecución. Su uso más común es para finalizar (matar) procesos, pero también se puede 
utilizar para enviar otras señales que afectan el comportamiento del proceso.

Ejemplos de Utilización
Terminar un Proceso Específico
Para enviar la señal de terminación (SIGTERM, por defecto) a un proceso con un ID 
específico:
    kill 1234
Aquí, 1234 es el ID del proceso que deseas terminar.

Forzar la Terminación de un Proceso
Para enviar la señal SIGKILL a un proceso, forzando su terminación inmediata:
    kill -9 1234
Aquí, -9 especifica la señal SIGKILL.

Suspender un Proceso
Para enviar la señal SIGSTOP y suspender un proceso:
    kill -19 1234
Aquí, -19 especifica la señal SIGSTOP.

Reanudar un Proceso Suspendido
Para reanudar un proceso que ha sido suspendido:
    kill -18 1234
Aquí, -18 especifica la señal SIGCONT.

Enviar una Señal a Todos los Procesos de un Usuario
Para enviar una señal a todos los procesos de un usuario específico, puedes usar el 
nombre de usuario junto con killall:
    killall -u nombre_usuario
Esto enviará la señal SIGTERM a todos los procesos del usuario nombre_usuario.

Enviar una Señal a un Grupo de Procesos
Para enviar una señal a todos los procesos en un grupo específico, usa kill con el 
ID de grupo de procesos (PID precedido por -):
    kill -TERM -1234
Aquí, -1234 representa el ID de grupo de procesos.

h_ 
1. ps (Process Status)
Funcionalidad: Muestra información sobre los procesos en ejecución en el sistema. 
Puede mostrar una lista detallada de procesos actuales y sus estados.
Parámetros Comunes:
    -e o -A: Muestra todos los procesos.
    -f: Muestra la información completa sobre los procesos.
    -u <usuario>: Muestra procesos de un usuario específico.
    -p <pid>: Muestra información sobre un proceso específico (por ID).
    aux: Muestra una lista de procesos en formato extendido, incluyendo procesos de otros usuarios.
Ejemplo:
    ps aux
Muestra una lista completa de todos los procesos en ejecución.

2. kill
Funcionalidad: Envía señales a procesos para controlar su comportamiento, como 
terminar o suspender procesos.
Parámetros Comunes:
    <pid>: ID del proceso al que se le enviará la señal.
    -9: Envía la señal SIGKILL, forzando la terminación inmediata.
    -15: Envía la señal SIGTERM, solicitando la terminación ordenada (por defecto).
Ejemplo:
    kill -9 1234
Termina el proceso con ID 1234 inmediatamente.

3. pstree
Funcionalidad: Muestra los procesos en ejecución en forma de un árbol, mostrando cómo 
los procesos están relacionados entre sí (padre e hijo).
Parámetros Comunes:
    -p: Muestra los ID de proceso junto con los nombres.
    -u: Muestra el usuario que ejecuta cada proceso.
    -A: Usa un estilo de árbol ASCII (si no está especificado, usa un estilo de árbol más tradicional).

Ejemplo:
    pstree -p
Muestra los procesos en forma de árbol con sus ID de proceso.

4. killall
Funcionalidad: Envía señales a todos los procesos que coinciden con un nombre dado.
Parámetros Comunes:
    <nombre_proceso>: Nombre del proceso al que se enviará la señal.
    -9: Envía la señal SIGKILL.
    -15: Envía la señal SIGTERM (por defecto).
Ejemplo:
    killall -9 nombre_proceso
Termina todos los procesos con el nombre nombre_proceso inmediatamente.

5. top
Funcionalidad: Muestra una vista en tiempo real de los procesos en ejecución, 
incluyendo el uso de CPU y memoria. Se actualiza periódicamente.
Parámetros Comunes:
    -d <segundos>: Establece el intervalo de actualización en segundos.
    -b: Modo de lote, útil para redireccionar la salida a un archivo.
Ejemplo:
    top -d 2
Muestra los procesos con una actualización cada 2 segundos.

6. nice
Funcionalidad: Establece la prioridad de un proceso. La prioridad se indica mediante 
el "valor de niceness", que afecta cuánto tiempo de CPU recibe el proceso en 
comparación con otros.
Parámetros Comunes:
    -n <valor>: Establece el valor de niceness (de -20 a 19, donde -20 es la mayor prioridad y 19 la menor).
    <comando>: El comando a ejecutar con el valor de niceness especificado.
Ejemplo:
    nice -n 10 comando
Ejecuta comando con una prioridad menor, dando preferencia a otros procesos.

Comparación
ps vs. top: ps muestra una instantánea de los procesos en el momento en que se ejecuta, 
mientras que top proporciona una vista dinámica y en tiempo real de los procesos.

kill vs. killall: kill se usa para enviar señales a procesos específicos mediante su 
ID, mientras que killall envía señales a todos los procesos con un nombre dado.

pstree vs. ps: pstree muestra la jerarquía de procesos en forma de árbol, lo que es 
útil para ver la relación padre-hijo, mientras que ps muestra una lista plana de 
procesos sin mostrar relaciones jerárquicas.

top vs. nice: top es para monitoreo en tiempo real, mientras que nice es para ajustar 
la prioridad de procesos. Se pueden usar juntos para gestionar el rendimiento del 
sistema.

7) a_ En GNU/Linux, el concepto de empaquetar archivos se refiere al proceso de 
combinar varios archivos y directorios en un único archivo, generalmente con el fin 
de facilitar su distribución, instalación o copia. El empaquetado es común cuando se 
quiere compartir software o archivos de manera organizada. Este archivo empaquetado 
no necesariamente está comprimido, pero se puede comprimir para reducir su tamaño.

b_ El tamaño del archivo empaquetado (archivos_empaquetados.tar) es igual a la suma 
de los tamaños individuales de los 4 archivos. Esto se debe a que el comando tar 
simplemente empaqueta (combina) los archivos en un solo archivo, sin comprimirlos. 
Por lo tanto, el tamaño total no se reduce; solo se organizan los archivos de manera 
más conveniente en un solo contenedor.

c y d_ Para comprimir y reducir el tamaño del archivo empaquetado, puedes usar compresión 
gzip o bzip2. Por ejemplo:

    tar cvzf archivos_empaquetados.tar.gz archivo1.txt archivo2.txt archivo3.txt archivo4.txt

d_ 1. tar
    Descripción: tar (abreviatura de tape archive) es una utilidad ampliamente 
    utilizada para empaquetar varios archivos y directorios en un solo archivo. 
    Este archivo empaquetado se conoce comúnmente como un tarball.
    Uso principal: Empaquetar y desempaquetar archivos.
    Opciones comunes:
    -c : Crear un nuevo archivo tar.
    -v : Modo detallado (muestra el progreso).
    -f : Especifica el nombre del archivo tar.
    -x : Extraer los archivos del archivo tar.
    -z : Comprimir o descomprimir usando gzip.
    -j : Comprimir o descomprimir usando bzip2.
    Ejemplos:
        Crear un archivo tar:
        tar cvf archivos.tar archivo1.txt archivo2.txt

        Extraer un archivo tar:
        tar xvf archivos.tar

        Crear un archivo tar comprimido con gzip:
        tar cvzf archivos.tar.gz archivo1.txt archivo2.txt

    2. grep
    Descripción: grep (global regular expression print) es una utilidad para buscar 
    patrones de texto dentro de archivos. Es extremadamente útil para filtrar 
    información relevante de archivos de texto o salida de comandos.

    Uso principal: Buscar texto en archivos o entradas estándar.

    Opciones comunes:
    -i : Ignorar mayúsculas y minúsculas.
    -r o -R : Buscar de forma recursiva en directorios.
    -l : Mostrar solo los nombres de archivos que contienen coincidencias.
    -n : Mostrar números de línea junto con la salida.
    -v : Invertir la coincidencia, mostrando líneas que no coincidan con el patrón.
    Ejemplos:
    Buscar una palabra en un archivo:
    grep "palabra" archivo.txt

    Buscar recursivamente en un directorio ignorando mayúsculas:
    grep -ri "palabra" /ruta/al/directorio

    3. gzip
    Descripción: gzip es una utilidad de compresión que se utiliza para reducir el 
    tamaño de los archivos mediante el algoritmo de compresión Lempel-Ziv (LZ77). 
    Los archivos comprimidos tienen la extensión .gz.

    Uso principal: Comprimir y descomprimir archivos.

    Opciones comunes:
    -d : Descomprimir un archivo .gz.
    -k : Mantener el archivo original después de la compresión.
    -v : Modo detallado (muestra el progreso de compresión).
    Ejemplos:
    Comprimir un archivo:
    gzip archivo.txt

    Descomprimir un archivo:
    gzip -d archivo.txt.gz

    Comprimir un archivo y mantener el original:
    gzip -k archivo.txt

    4. zgrep
    Descripción: zgrep es una versión del comando grep que permite buscar patrones 
    dentro de archivos comprimidos con gzip (.gz). Descomprime temporalmente los
    archivos para realizar la búsqueda sin necesidad de descomprimirlos manualmente.

    Uso principal: Buscar texto en archivos comprimidos con .gz.

    Opciones comunes: Las mismas que grep, ya que zgrep pasa sus opciones a grep.

    Ejemplos:
    Buscar una palabra en un archivo comprimido:
    zgrep "palabra" archivo.txt.gz

    Buscar recursivamente en archivos .gz en un directorio:
    zgrep -r "palabra" /ruta/al/directorio

    5. wc
    Descripción: wc (word count) es una utilidad que cuenta líneas, palabras y 
    caracteres en archivos de texto o en la entrada estándar.

    Uso principal: Contar líneas, palabras, caracteres o bytes en archivos.

    Opciones comunes:
    -l : Contar solo líneas.
    -w : Contar solo palabras.
    -c : Contar solo bytes.
    -m : Contar solo caracteres.

    Ejemplos:
    Contar líneas, palabras y caracteres en un archivo:
    wc archivo.txt

    Contar solo palabras en un archivo:
    wc -w archivo.txt

    Contar solo líneas en un archivo:
    wc -l archivo.txt

8) 
ls -l > prueba
Acción: Lista los archivos y directorios del directorio actual en formato detallado 
(-l) y redirige la salida a un archivo llamado prueba. Si prueba no existe, se creará; 
si existe, se sobrescribirá.
Ejecutabilidad: Sí, se puede ejecutar sin problemas por un usuario normal.

ps > PRUEBA
Acción: Muestra los procesos en ejecución para el usuario actual y redirige la salida 
a un archivo llamado PRUEBA.
Ejecutabilidad: Sí, se puede ejecutar sin problemas por un usuario normal.

chmod 710 prueba
Acción: Cambia los permisos del archivo prueba para que el propietario tenga permisos 
de lectura, escritura y ejecución (7), los miembros del grupo tengan permiso de 
ejecución (1), y otros no tengan permisos (0).
Ejecutabilidad: Sí, se puede ejecutar si el usuario actual es el propietario del 
archivo prueba.

chown root:root PRUEBA
Acción: Cambia el propietario y el grupo del archivo PRUEBA a root.
Ejecutabilidad: No. Este comando requiere privilegios de superusuario (root). Un 
usuario normal no puede cambiar la propiedad de archivos a root.

chmod 777 PRUEBA
Acción: Cambia los permisos del archivo PRUEBA para que todos (propietario, grupo, y 
otros) tengan permisos de lectura, escritura y ejecución (777).
Ejecutabilidad: Sí, se puede ejecutar si el usuario actual es el propietario del 
archivo PRUEBA.

chmod 700 /etc/passwd
Acción: Intenta cambiar los permisos del archivo /etc/passwd para que solo el 
propietario tenga permisos de lectura, escritura y ejecución (700).
Ejecutabilidad: No. Este comando requiere privilegios de superusuario (root) porque 
intenta cambiar los permisos de un archivo del sistema.

passwd root
Acción: Intenta cambiar la contraseña del usuario root.
Ejecutabilidad: No. Este comando requiere privilegios de superusuario para cambiar la 
contraseña de root.

rm PRUEBA
Acción: Elimina el archivo PRUEBA.
Ejecutabilidad: Sí, se puede ejecutar si el usuario tiene permisos de escritura en el 
directorio actual y es el propietario del archivo PRUEBA.

man /etc/shadow
Acción: Intenta mostrar la página de manual del archivo /etc/shadow.
Ejecutabilidad: No. No hay una página de manual para un archivo específico como 
/etc/shadow; man se utiliza para mostrar la documentación de comandos, no de archivos.

find / -name *.conf
Acción: Busca en todo el sistema (/) archivos cuyo nombre coincida con *.conf.
Ejecutabilidad: Puede ejecutarse, pero el usuario encontrará permisos denegados en 
muchos directorios que no tiene permiso para leer. Aun así, el comando en sí no 
requiere privilegios de root para ejecutarse.

usermod root -d /home/newroot -L
Acción: Intenta cambiar el directorio de inicio de root a /home/newroot y bloquear la 
cuenta de root.
Ejecutabilidad: No. usermod requiere privilegios de superusuario (root) para modificar 
cuentas de usuario del sistema.

cd /root
Acción: Cambia el directorio actual a /root, que es el directorio de inicio de root.
Ejecutabilidad: No. El directorio /root está restringido solo para el usuario root.

rm *
Acción: Elimina todos los archivos en el directorio actual.
Ejecutabilidad: Sí, se puede ejecutar si el usuario tiene permisos de escritura en el 
directorio actual. Puede ser peligroso si se ejecuta en el directorio incorrecto.

cd /etc
Acción: Cambia el directorio actual a /etc.
Ejecutabilidad: Sí, se puede ejecutar ya que cualquier usuario puede navegar a /etc.

cp * /home -R
Acción: Copia recursivamente todos los archivos y subdirectorios del directorio actual 
(/etc en este caso) al directorio /home.
Ejecutabilidad: No, ya que copiar algunos archivos de /etc a /home requerirá permisos 
de root debido a restricciones de lectura y escritura en algunos archivos.

shutdown
Acción: Intenta apagar o reiniciar el sistema.
Ejecutabilidad: No. Este comando requiere privilegios de superusuario (root).

9) a_ sudo kill 23

b_ sudo kill 1
    Al ejectutar este comando la terminal no me devolvio nada, sin embargo el comando
    no tuvo exito ya que Los procesos con PID 1 (init o systemd) están protegidos para 
    evitar que sean terminados por comandos normales. El sistema no dará un mensaje 
    de error porque el intento de terminar el proceso puede ser ignorado 
    silenciosamente por el sistema para evitar daños.

c_ Para buscar archivos cuyo nombre contiene la cadena .conf, puedes usar el comando 
find, que es muy útil para localizar archivos y directorios en el sistema basándose 
en diferentes criterios.

Comando para Buscar Archivos con .conf
El comando find te permite buscar archivos en un directorio y sus subdirectorios. Si 
deseas buscar en todo el sistema, puedes utilizar / como el directorio raíz. Aquí te 
muestro cómo hacerlo:

    find / -type f -name "*.conf"

Explicación de los Parámetros
    / : Especifica el directorio raíz desde el que comienza la búsqueda. Puedes 
    cambiar / por cualquier directorio específico si quieres limitar la búsqueda a 
    una ubicación particular.

    -type f : Busca solo archivos (no directorios).

    -name "*.conf" : Busca archivos cuyos nombres terminen con .conf.

Consideraciones
Permisos: Si buscas en todo el sistema (/), es posible que necesites permisos de 
superusuario para acceder a algunos directorios. Puedes usar sudo para ejecutar el 
comando con privilegios elevados:

    find / -type f -name "*.conf"

Rendimiento: Buscar en todo el sistema puede llevar tiempo y generar una gran cantidad 
de salida. Si solo estás interesado en ciertos directorios, cambia / por el directorio 
deseado para limitar la búsqueda, por ejemplo:

    find /etc -type f -name "*.conf"

d_ Pasos Detallados
Reemplaza <tu-nombre-de-usuario> con tu nombre de usuario. Por ejemplo, si tu nombre 
de usuario es juan, el comando sería:

    ps aux > /home/juan/procesos

Verifica los Permisos:
Asegúrate de que tienes permisos para escribir en el directorio /home/<tu-nombre-de-
usuario>/. Generalmente, si estás trabajando en tu propio directorio de usuario, 
deberías tener los permisos adecuados.

Comprobar el Archivo:
Después de ejecutar el comando, puedes verificar que el archivo se haya creado y 
contiene la lista de procesos usando cat o less:

    cat /home/<tu-nombre-de-usuario>/procesos

e_ chmod 751 /home/<tu_nombre_de_usuario>/xxxx

f_ chmod 650 /home/<tu_nombre_de_usuario>/yyyy

g_  rm -rf /tmp/*
    Explicación del Comando:
    rm: Comando utilizado para eliminar archivos y directorios.

    -r: Opción para eliminar de manera recursiva. Esto es necesario para eliminar 
    directorios y su contenido.

    -f: Opción para forzar la eliminación sin pedir confirmación. Este es 
    especialmente útil para evitar mensajes de error si algunos archivos están 
    bloqueados o protegidos contra escritura.

    /tmp/*: Ruta al directorio /tmp y todos los archivos (*) dentro de él.

h_ sudo chown iso2010 /opt/isodata

i_ pwd >> /home/<tu_nombre_de_usuario>/donde

10) a_ su
    ingresar contraseña de usuario

b_ sudo useradd vcapelli
   sudo passwd "xxxx"

c_ Después de crear un usuario, varios archivos y directorios en el sistema se 
modifican o se crean:

Archivos Modificados:

/etc/passwd:
Este archivo se actualiza con la nueva entrada para el usuario. Contiene la 
información básica del usuario, como el nombre de usuario, el UID, el GID, y el 
directorio de inicio.

/etc/shadow:
Este archivo se actualiza para almacenar la contraseña cifrada del usuario y otra 
información relacionada con las contraseñas.

/etc/group:
Si se creó un grupo con el mismo nombre que el usuario (por defecto, vcapelli), este 
archivo se actualizará con la nueva entrada del grupo.

Directorio de Inicio del Usuario:
Un nuevo directorio de inicio se crea en /home/vcapelli. Este directorio contiene los 
archivos y configuraciones del usuario.

d_ sudo mkdir /tmp/cursada2017

e_ sudo cp -r /var/log/* /tmp/cursada2017/

f_ sudo chown -R cgomez:users /tmp/cursada2017

g_ sudo chmod -R 723 /tmp/cursada2017

h_ Presiona Ctrl + Alt + F1 a F6 para abrir una terminal virtual.

i_ Para saber cual es el nombre de la terminal
    tty

j_ Verificar la Cantidad de Procesos Activos en el Sistema
    ps -e | wc -l

k_ Verificar la Cantidad de Usuarios Conectados al Sistema
    who | wc -l

l_ Envía un Mensaje al Usuario vcapelli:
    sudo write vcapelli

m_ Apagar el Sistema
    sudo shutdown now

11) a_ 
    mkdir 23103/3
    cd 23103/3

b_ vi LEAME

c_ chmod 017 LEAME

d_
    cd /etc
    ls -l /etc > leame

Si ya existe un archivo llamado LEAME en el directorio personal, se puede crear un 
archivo con el nombre leame porque los nombres de archivos en Linux son sensibles a 
mayúsculas y minúsculas. Esto significa que LEAME y leame son considerados archivos 
distintos debido a la diferencia en el caso de las letras.

e_ Buscar un archivo específico por nombre:

    find /ruta/del/directorio -name "nombre_archivo"

Buscar archivos con una extensión específica:

    find /ruta/del/directorio -name "*.ext"

Buscar archivos con un patrón específico en el nombre:

find /ruta/del/directorio -name "*patron*"

f_ find / -type f -name "*.so" > .ejercicio_f 2>/dev/null

Explicación del Comando:
    find /: Inicia la búsqueda en la raíz del sistema de archivos (/).
    -type f: Limita la búsqueda a archivos (no directorios).
    -name "*.so": Busca archivos cuyo nombre termine con .so.
    >: Redirige la salida estándar al archivo .ejercicio_f.
    .ejercicio_f: Nombre del archivo donde se guardará el resultado de la búsqueda.
    2>/dev/null: Redirige los mensajes de error (por ejemplo, "Permission denied") a 
    /dev/null para que no aparezcan en la salida.

12) 
1. mkdir iso
Este comando crea un directorio llamado iso en el directorio de trabajo actual. Si 
el directorio ya existe, el comando fallará indicando que el archivo ya existe.

2. cd ./iso ; ps > f0
    cd ./iso: Cambia al directorio iso que se acaba de crear.
    ps > f0: Ejecuta el comando ps que muestra información sobre los procesos en ejecución y redirige la salida al archivo f0 en el directorio iso.

3. ls > f1
Este comando lista los archivos y directorios del directorio actual (que ahora es 
iso) y redirige la salida al archivo f1. Si f1 no existe, se creará; si existe, 
será sobrescrito.

4. cd /
Este comando cambia al directorio raíz del sistema de archivos (/).

5. echo $HOME
Este comando imprime el valor de la variable de entorno $HOME, que contiene la ruta 
al directorio de inicio del usuario.

6. ls -l $> $HOME/iso/ls
Este comando está mal escrito debido a $> que no es válido en Bash. Debería haber 
sido algo como ls -l > $HOME/iso/ls, que listaría los archivos en formato largo (-l) 
y redirigiría la salida al archivo ls en el directorio iso en el directorio de inicio 
del usuario.

7. cd $HOME; mkdir f2
    cd $HOME: Cambia al directorio de inicio del usuario.
    mkdir f2: Crea un directorio llamado f2 en el directorio de inicio del usuario.

8. ls -ld f2
Este comando lista el directorio f2 en formato largo (-l) mostrando información 
sobre los permisos, propietario, tamaño, y más. La opción -d indica que se debe 
listar el directorio f2 en sí, no su contenido.

9. chmod 341 f2
Este comando cambia los permisos del directorio f2 a 341. Los permisos serán:
    Propietario: -wx (escritura y ejecución)
    Grupo: --- (sin permisos)
    Otros: --x (solo ejecución)

10. touch dir
Este comando crea un archivo vacío llamado dir en el directorio actual. Si el archivo 
ya existe, simplemente actualiza su timestamp de última modificación.

11. cd f2
Este comando intenta cambiar al directorio f2. Puede fallar si los permisos no están
establecidos correctamente, es decir, si el usuario no tiene permisos de ejecución 
(x) sobre f2.

12. cd ~/iso
Este comando cambia al directorio iso en el directorio de inicio del usuario 
($HOME/iso).

13. pwd >f3
Este comando guarda la ruta actual del directorio (obtenida con pwd) en el archivo 
f3 en el directorio actual (iso).

14. ps | grep ' ps ' | wc -l >> ../f2/f3
Este comando:
    ps muestra los procesos en ejecución.
    grep ' ps ' busca líneas que contengan la palabra "ps".
    wc -l cuenta el número de líneas encontradas.
    >> ../f2/f3 agrega el resultado al final del archivo f3 ubicado en ../f2.

15. chmod 700 ../f2 ; cd ..
    chmod 700 ../f2: Cambia los permisos de f2 para que solo el propietario tenga permisos completos (lectura, escritura, y ejecución).
    cd ..: Retrocede un directorio (sube un nivel en la jerarquía de directorios).

16. find . -name etc/passwd
Este comando está mal escrito. El uso correcto sería find . -name "etc/passwd", pero 
esto tampoco tendría mucho sentido porque find busca nombres de archivos, no rutas. 
Debe buscar passwd o usar la opción -path.

17. find / -name etc/passwd
De nuevo, este comando no es válido. Debería ser algo como find / -name "passwd" o 
find / -path "*/etc/passwd". Además, requiere permisos de superusuario para buscar 
en todos los directorios.

18. mkdir ejercicio5
Este comando crea un directorio llamado ejercicio5 en el directorio actual.

13) Comandos para realizar las acciones solicitadas:
Mover el archivo f3 al directorio de trabajo /home/usuario:
    mv /home/usuario/dir1/f3 /home/usuario/

Copiar el archivo f4 en el directorio dir11:
    cp /home/usuario/dir2/f4 /home/usuario/dir1/dir11/

Copiar el archivo f4 en el directorio dir11 pero renombrarlo como f7:

    cp /home/usuario/dir2/f4 /home/usuario/dir1/dir11/f7

Crear el directorio copia dentro del directorio usuario y copiar en él el contenido de dir1:

    mkdir /home/usuario/copia
    cp -r /home/usuario/dir1/* /home/usuario/copia/

Renombrar el archivo f1 por el nombre archivo y ver los permisos del mismo:

    mv /home/usuario/f1 /home/usuario/archivo
    ls -l /home/usuario/archivo

Cambiar los permisos del archivo llamado archivo de la siguiente manera:

Usuario: Permisos de lectura y escritura
Grupo: Permisos de ejecución
Otros: Todos los permisos

    chmod 617 /home/usuario/archivo

Renombrar los archivos f3 y f4 para que se llamen f3.exe y f4.exe respectivamente:

    mv /home/usuario/f3 /home/usuario/f3.exe
    mv /home/usuario/dir2/f4 /home/usuario/dir2/f4.exe

Cambiar los permisos de los dos archivos renombrados (f3.exe y f4.exe) de la siguiente 
manera, utilizando un único comando:

Usuario: Ningún permiso
Grupo: Permisos de escritura
Otros: Permisos de escritura y ejecución

    chmod 023 /home/usuario/f3.exe /home/usuario/dir2/f4.exe

14)
(a) Crear un directorio llamado logs en el directorio /tmp:

mkdir /tmp/logs

mkdir es el comando para crear directorios.
/tmp/logs es la ruta del nuevo directorio a crear.

(b) Copiar todo el contenido del directorio /var/log en el directorio creado en el 
punto anterior:

cp -r /var/log/* /tmp/logs/

cp es el comando para copiar archivos.
-r indica que se copie de manera recursiva, es decir, se incluyen subdirectorios.
/var/log/* indica que se debe copiar todo el contenido de /var/log.
/tmp/logs/ es el directorio de destino.

(c) Empaquetar el directorio creado en 1, el archivo resultante se debe llamar 
"misLogs.tar":

tar -cvf misLogs.tar -C /tmp logs

tar es el comando para empaquetar archivos y directorios.
-c crea un nuevo archivo tar.
-v muestra el progreso de la operación.
-f misLogs.tar especifica el nombre del archivo tar.
-C /tmp logs empaqueta el directorio logs desde el directorio /tmp.

(d) Empaquetar y comprimir el directorio creado en 1, el archivo resultante se debe llamar "misLogs.tar.gz":

tar -czvf misLogs.tar.gz -C /tmp logs

tar empaqueta y comprime.
-c crea un nuevo archivo tar.
-z comprime con gzip.
-v muestra el progreso de la operación.
-f misLogs.tar.gz especifica el nombre del archivo tar comprimido.
-C /tmp logs empaqueta el directorio logs desde el directorio /tmp.

(e) Copiar los archivos creados en 3 y 4 al directorio de trabajo de su usuario:

cp misLogs.tar misLogs.tar.gz ~/

cp copia archivos.
misLogs.tar misLogs.tar.gz son los archivos a copiar.
~/ es el directorio de trabajo del usuario (HOME).

(f) Eliminar el directorio creado en 1, logs:

rm -r /tmp/logs

rm es el comando para eliminar archivos y directorios.
-r permite la eliminación recursiva.
/tmp/logs es el directorio a eliminar.

(g) Desempaquetar los archivos creados en 3 y 4 en 2 directorios diferentes:

Para misLogs.tar:

mkdir ~/misLogs_tar
tar -xvf ~/misLogs.tar -C ~/misLogs_tar

mkdir ~/misLogs_tar crea un directorio llamado misLogs_tar.
tar -xvf ~/misLogs.tar -C ~/misLogs_tar desempaca misLogs.tar en el directorio 
misLogs_tar.

Para misLogs.tar.gz:

mkdir ~/misLogs_tar_gz
tar -xzvf ~/misLogs.tar.gz -C ~/misLogs_tar_gz

mkdir ~/misLogs_tar_gz crea un directorio llamado misLogs_tar_gz.
tar -xzvf ~/misLogs.tar.gz -C ~/misLogs_tar_gz desempaca y descomprime misLogs.tar.gz 
en el directorio misLogs_tar_gz.